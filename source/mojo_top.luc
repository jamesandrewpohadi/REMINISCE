module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    output spi_miso,        // AVR SPI MISO
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    output avr_rx,          // AVR RX (FPGA TX)
    input l1,
    input l2,
    input l3,
    input o,
    input u,
    input d,
    input l,
    input r,
    output x0,
    output x1,
    output x2,
    output x3,
    output x4,
    output x5,
    output x6,
    output x7,
    output y0,
    output y1,
    output y2,
    output y3,
    output y4,
    output y5,
    output y6,
    output y7
  ) {
  
  sig rst;                  // reset signal
  dff tl1[1](.clk(clk), .rst(rst)); 
  dff tl2[1](.clk(clk), .rst(rst)); 
  dff tl3[1](.clk(clk), .rst(rst)); 
  dff tu[1](.clk(clk), .rst(rst)); 
  dff td[1](.clk(clk), .rst(rst)); 
  dff tl[1](.clk(clk), .rst(rst)); 
  dff tr[1](.clk(clk), .rst(rst)); 
  dff to[1](.clk(clk), .rst(rst)); 
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    edge_detector ud(#RISE(1), #FALL(0));
    edge_detector dd(#RISE(1), #FALL(0));
    edge_detector ld(#RISE(1), #FALL(0));
    edge_detector rd(#RISE(1), #FALL(0));
    edge_detector od(#RISE(1), #FALL(0));
    edge_detector l1d(#RISE(1), #FALL(0));
    edge_detector l2d(#RISE(1), #FALL(0));
    edge_detector l3d(#RISE(1), #FALL(0));
    .rst(rst) {
      //emulator myGame; // define our device
      //fsm state(#INIT(IDLE)) = {IDLE, RETURN, CHECK, INCR, PRE_L, PRE_R, PRE_U, PRE_D, L, R, U, D, PRE_L1, L1, L1_DS1, L1_DS2, L1_DS3, L1_DS4, L1_DSW, L1_P1, L1_P2, L1_P3, L1_P4, L1_PW, L2, L2_DS1, L2_DS2, L2_DS3, L2_DS4, L2_DS5, L2_DS6, L2_DSW, L2_P1, L2_P2, L2_P3, L2_P4, L2_P5, L2_P6, L2_PW, L3, L3_DS1, L3_DS2, L3_DS3, L3_DS4, L3DS5, L3_DS6, L3_DS7, L3_DS8, L3_DS9, L3_DS10, L3_DSW, L3_P1, L3_P2, L3_P3, L3_P4, L3_P5, L3_P6, L3_P7, L3_P8, L3_P9, L3_P10, L3_PW, DF};
    }
  }
  
  //dff counter[28](.clk(clk), .rst(rst)); // Define the counter
  
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    led = 8h00;             // turn LEDs off
    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
    avr_rx = bz;            // not using serial port
    ud.in = u;
    dd.in = d;
    ld.in = l;
    rd.in = r;
    od.in = o;
    l1d.in = l1;
    l2d.in = l2;
    l3d.in = l3;
    if(l1d.out){
      tl1.d=~tl1.q;
    }
    led[0] = tl1.q;
    if(l2d.out){
      tl2.d=~tl2.q;
    }
    led[1] = tl2.q;
    if(od.out){
      to.d=~to.q;
    }
    led[7] = to.q;
    if(l3d.out){
      tl3.d=~tl3.q;
    }
    led[2] = tl3.q;
    if(ud.out){
      tu.d=~tu.q;
    }
    led[3] = tu.q;
    if(ld.out){
      tl.d=~tl.q;
    }
    led[5] = tl.q;
    if(dd.out){
      td.d=~td.q;
    }
    led[6] = td.q;
    if(rd.out){
      td.d=~td.q;
    }
    led[6] = td.q;
    x0 = 1b1;
    x1 = 1b1;
    x2 = 1b0;
    x3 = 1b0;
    x4 = 1b1;
    x5 = 1b1;
    x6 = 1b1;
    x7 = 1b1;
    y0 = 1b1;
    y1 = 1b1;
    y2 = 1b0;
    y3 = 1b0;
    y4 = 1b0;
    y5 = 1b0;
    y6 = 1b0;
    y7 = 1b0;
    
  }
}