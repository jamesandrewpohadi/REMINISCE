module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,      // AVR RX buffer full
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8],
    input button_level_1,
    input button_level_2,
    input button_level_3,
    output p0,
    output p1,
    output p2,
    output p3,
    output p4,
    output p5,
    output p6,
    output p7,
    output p8,
    output p9,
    output p10,
    output p11,
    output p12,
    output p13,
    output p14,
    output p15
  ) {
  
  sig rst;                  // reset signal
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    .rst(rst) {
      
    }
  }
  board myBoard;
  rom myRom;
  mux_2 mux2; 
  mux_5 mux5;
  sig level[2];
  sig sequence[4];
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    led = 8h00;             // turn LEDs off
    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
    avr_rx = bz;            // not using serial port
    
    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    
    //TEST BOARD
    
    
    myBoard.b[7:0] = io_dip[0];
    myBoard.b[15:8] = io_dip[1];
    p0 = myBoard.p0;
    p1 = myBoard.p1;
    p2 = myBoard.p2;
    p3 = myBoard.p3;
    p4 = myBoard.p4;
    p5 = myBoard.p5;
    p6 = myBoard.p6;
    p7 = myBoard.p7;
    p8 = myBoard.p8;
    p9 = myBoard.p9;
    p10 = myBoard.p10;
    p11 = myBoard.p11;
    p12 = myBoard.p12;
    p13 = myBoard.p13;
    p14 = myBoard.p14;
    p15 = myBoard.p15;
    
    //io_led[2][0] = io_button[0];
    //io_led[2][1] = io_button[1];
    //io_led[2][2] = io_button[2];
    //io_led[2][3] = io_button[3];
    //io_led[2][4] = io_button[4];
    //io_led[1][3] = io_button[3];
    
    
    
    //Test ROM
    level = io_dip[2][5:4];
    sequence = io_dip[2][3:0];
    
    myRom.address = c{level,sequence};
    io_led[1] = myRom.out[15:8];
    io_led[0] = myRom.out[7:0];
    
    //Test Buttons (Buttons work Fine)
    //Test mux2
    mux2.a = 1111111111111111;
    mux2.b = 0000000000000000;
    mux2.sel = button_level_1;
    io_led[2] = mux2.out[15:8];
    
    //Test MUX_5;
    mux5.sel = io_dip[2][2:0];
    mux5.a = 1111111111111111;
    mux5.b = 0000000000000000;
    mux5.c = 0110101010101010;
    mux5.d = 0101010101010101;
    mux5.e = 1010101010101010;
    
    io_seg = mux5.out[15:8]; 

    
  }
}